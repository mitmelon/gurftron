import Dexie from"dexie";import LZString from"lz-string";const CONFIG={STORAGE:{DB_NAME:"GurftronCoreDB",DB_VERSION:6,STORES:{THREATS:"threats",WHITELIST:"whitelist",ERRORS:"errors",USERS:"users",METRICS:"metrics"},MAX_COMPRESSED_SIZE:1048576},NATIVE_HOST:"com.gurftron.server",DOMAIN_INFO_CACHE_TTL:6048e5};class CryptoUtils{static async generateHash(t){const e=new TextEncoder,r=await crypto.subtle.digest("SHA-256",e.encode(JSON.stringify(t)));return Array.from(new Uint8Array(r)).map(t=>t.toString(16).padStart(2,"0")).join("")}}class DexieStorageAdapter{constructor(){this.db=null}async initialize(){return this.db=new Dexie(CONFIG.STORAGE.DB_NAME),this.db.version(CONFIG.STORAGE.DB_VERSION).stores({[CONFIG.STORAGE.STORES.THREATS]:"id, timestamp, hash, threatType, severity, url, contentHash",[CONFIG.STORAGE.STORES.WHITELIST]:"id, timestamp, status, url",[CONFIG.STORAGE.STORES.ERRORS]:"id, timestamp, errorType",[CONFIG.STORAGE.STORES.USERS]:"id, timestamp",[CONFIG.STORAGE.STORES.METRICS]:"date, timestamp"}),await this.db.open(),!0}async save(t,e,r,a={}){try{const s=LZString.compressToUTF16(JSON.stringify(r));if(2*s.length>CONFIG.STORAGE.MAX_COMPRESSED_SIZE)throw new Error(`Compressed data exceeds ${CONFIG.STORAGE.MAX_COMPRESSED_SIZE} bytes`);const i={id:e,data:s,hash:await CryptoUtils.generateHash(r),timestamp:Date.now(),compressed:!0,...a};return await this.db.table(t).put(i),i.hash}catch(t){throw console.error("Dexie save failed:",t),t}}async get(t,e){try{const r=await this.db.table(t).get(e);return r?r.compressed?JSON.parse(LZString.decompressFromUTF16(r.data)):r.data:null}catch(t){return console.error("Dexie get failed:",t),null}}async query(t,e={}){try{const r=this.db.table(t);let a=r.toCollection();if(e.index&&void 0!==e.value)try{a=r.where(e.index).equals(e.value)}catch(t){a=r.toCollection()}return(await a.limit(1e4).toArray()).map(t=>({...t,data:t.compressed?JSON.parse(LZString.decompressFromUTF16(t.data)):t.data})).filter(t=>!(e.minTimestamp&&t.timestamp<e.minTimestamp||e.maxTimestamp&&t.timestamp>e.maxTimestamp||e.threatType&&t.threatType!==e.threatType||e.severity&&t.severity!==e.severity||e.url&&t.url!==e.url||e.contentHash&&t.contentHash!==e.contentHash||e.domain&&t.domain!==e.domain||e.country&&t.country!==e.country))}catch(t){return console.error("Dexie query failed:",t),[]}}async getAllKeys(t){try{return await this.db.table(t).toCollection().primaryKeys()}catch(t){return console.error("Dexie getAllKeys failed:",t),[]}}async logError(t,e){try{const r=await CryptoUtils.generateHash({errorType:t,message:e,timestamp:Date.now()});await this.save(CONFIG.STORAGE.STORES.ERRORS,r,{errorType:t,message:e,timestamp:Date.now()},{errorType:t})}catch(t){console.error("Dexie logError failed:",t)}}async updateMetrics(t){try{const e=new Date,r=`${e.getFullYear()}-${String(e.getMonth()+1).padStart(2,"0")}-${String(e.getDate()).padStart(2,"0")}`,a=await this.db.table(CONFIG.STORAGE.STORES.METRICS).get(r),s={date:r,timestamp:Date.now(),scans:(a?.scans||0)+(t.scans||0),threatsDetected:(a?.threatsDetected||0)+(t.threatsDetected||0),llmCalls:(a?.llmCalls||0)+(t.llmCalls||0)};return await this.db.table(CONFIG.STORAGE.STORES.METRICS).put(s),s}catch(t){throw console.error("Dexie updateMetrics failed:",t),t}}async getMetrics(t=null){try{if(t)return await this.db.table(CONFIG.STORAGE.STORES.METRICS).get(t);const e=new Date,r=`${e.getFullYear()}-${String(e.getMonth()+1).padStart(2,"0")}-${String(e.getDate()).padStart(2,"0")}`;return await this.db.table(CONFIG.STORAGE.STORES.METRICS).get(r)}catch(t){return console.error("Dexie getMetrics failed:",t),null}}}export{DexieStorageAdapter,CONFIG};